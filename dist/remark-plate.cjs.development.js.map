{"version":3,"file":"remark-plate.cjs.development.js","sources":["../src/ast-types.ts","../src/deserialize.ts","../src/serialize.ts","../src/plugin.ts"],"sourcesContent":["export interface NodeTypes {\n  paragraph: 'p';\n  block_quote: 'blockquote';\n  code_block: 'code_block';\n  link: 'a';\n  ul_list: 'ul';\n  ol_list: 'ol';\n  listItem: 'li';\n  heading: {\n    1: 'h1';\n    2: 'h2';\n    3: 'h3';\n    4: 'h4';\n    5: 'h5';\n    6: 'h6';\n  };\n  emphasis_mark: 'italic';\n  strong_mark: 'bold';\n  delete_mark: 'strikethrough';\n  inline_code_mark: 'code';\n  thematic_break: 'hr';\n  image: 'img';\n}\n\nexport type MdastNodeType =\n  | 'paragraph'\n  | 'heading'\n  | 'list'\n  | 'listItem'\n  | 'link'\n  | 'image'\n  | 'blockquote'\n  | 'code'\n  | 'html'\n  | 'emphasis'\n  | 'strong'\n  | 'delete'\n  | 'inlineCode'\n  | 'thematicBreak'\n  | 'text';\n\nexport const defaultNodeTypes: NodeTypes = {\n  paragraph: 'p',\n  block_quote: 'blockquote',\n  code_block: 'code_block',\n  link: 'a',\n  ul_list: 'ul',\n  ol_list: 'ol',\n  listItem: 'li',\n  heading: {\n    1: 'h1',\n    2: 'h2',\n    3: 'h3',\n    4: 'h4',\n    5: 'h5',\n    6: 'h6',\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikethrough',\n  inline_code_mark: 'code',\n  thematic_break: 'hr',\n  image: 'img',\n};\n\nexport interface LeafType {\n  text: string;\n  strikethrough?: boolean;\n  bold?: boolean;\n  italic?: boolean;\n  code?: boolean;\n  parentType?: string;\n}\n\nexport interface BlockType {\n  type: string;\n  parentType?: string;\n  url?: string;\n  caption?: string;\n  language?: string;\n  break?: boolean;\n  children: Array<BlockType | LeafType>;\n}\n\nexport interface InputNodeTypes {\n  paragraph: string;\n  block_quote: string;\n  code_block: string;\n  link: string;\n  ul_list: string;\n  ol_list: string;\n  listItem: string;\n  heading: {\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n  };\n  emphasis_mark: string;\n  strong_mark: string;\n  delete_mark: string;\n  inline_code_mark: string;\n  thematic_break: string;\n  image: string;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\nexport interface OptionType<T extends InputNodeTypes = InputNodeTypes> {\n  nodeTypes?: RecursivePartial<T>;\n  linkDestinationKey?: string;\n  imageSourceKey?: string;\n  imageCaptionKey?: string;\n}\n\nexport interface MdastNode {\n  type?: MdastNodeType;\n  ordered?: boolean;\n  value?: string;\n  text?: string;\n  children?: Array<MdastNode>;\n  depth?: 1 | 2 | 3 | 4 | 5 | 6;\n  url?: string;\n  alt?: string;\n  lang?: string;\n  // mdast metadata\n  position?: any;\n  spread?: any;\n  checked?: any;\n  indent?: any;\n}\n\nexport type TextNode = { text?: string | undefined };\n\nexport type CodeBlockNode<T extends InputNodeTypes> = {\n  type: T['code_block'];\n  language: string | undefined;\n  children: Array<TextNode>;\n};\n\nexport type HeadingNode<T extends InputNodeTypes> = {\n  type:\n    | T['heading'][1]\n    | T['heading'][2]\n    | T['heading'][3]\n    | T['heading'][4]\n    | T['heading'][5]\n    | T['heading'][6];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ListNode<T extends InputNodeTypes> = {\n  type: T['ol_list'] | T['ul_list'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ListItemNode<T extends InputNodeTypes> = {\n  type: T['listItem'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ParagraphNode<T extends InputNodeTypes> = {\n  type: T['paragraph'];\n  break?: true;\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type LinkNode<T extends InputNodeTypes> = {\n  type: T['link'];\n  children: Array<DeserializedNode<T>>;\n  [urlKey: string]: string | undefined | Array<DeserializedNode<T>>;\n};\n\nexport type ImageNode<T extends InputNodeTypes> = {\n  type: T['image'];\n  children: Array<DeserializedNode<T>>;\n  [sourceOrCaptionKey: string]: string | undefined | Array<DeserializedNode<T>>;\n};\n\nexport type BlockQuoteNode<T extends InputNodeTypes> = {\n  type: T['block_quote'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type InlineCodeMarkNode<T extends InputNodeTypes> = {\n  type: T['inline_code_mark'];\n  children: Array<TextNode>;\n  language: string | undefined;\n};\n\nexport type ThematicBreakNode<T extends InputNodeTypes> = {\n  type: T['thematic_break'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ItalicNode<T extends InputNodeTypes> = {\n  [K in T['emphasis_mark']]: true;\n} & {\n  children: TextNode;\n};\nexport type BoldNode<T extends InputNodeTypes> = {\n  [K in T['strong_mark']]: true;\n} & {\n  children: TextNode;\n};\n\nexport type StrikeThoughNode<T extends InputNodeTypes> = {\n  [K in T['delete_mark']]: true;\n} & {\n  children: TextNode;\n};\n\nexport type InlineCodeNode = {\n  code: true;\n  text: string | undefined;\n};\n\nexport type DeserializedNode<T extends InputNodeTypes> =\n  | CodeBlockNode<T>\n  | HeadingNode<T>\n  | ListNode<T>\n  | ListItemNode<T>\n  | ParagraphNode<T>\n  | LinkNode<T>\n  | ImageNode<T>\n  | BlockQuoteNode<T>\n  | InlineCodeMarkNode<T>\n  | ThematicBreakNode<T>\n  | ItalicNode<T>\n  | BoldNode<T>\n  | StrikeThoughNode<T>\n  | InlineCodeNode\n  | TextNode;\n","import {\n  BlockQuoteNode,\n  CodeBlockNode,\n  defaultNodeTypes,\n  DeserializedNode,\n  HeadingNode,\n  ImageNode,\n  InputNodeTypes,\n  ItalicNode,\n  LinkNode,\n  ListItemNode,\n  ListNode,\n  MdastNode,\n  OptionType,\n  ParagraphNode,\n  TextNode,\n  ThematicBreakNode,\n  StrikeThoughNode,\n  BoldNode,\n} from './ast-types';\n\nexport default function deserialize<T extends InputNodeTypes>(\n  node: MdastNode,\n  opts?: OptionType<T>\n) {\n  const types = {\n    ...defaultNodeTypes,\n    ...opts?.nodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...opts?.nodeTypes?.heading,\n    },\n  };\n\n  const linkDestinationKey = opts?.linkDestinationKey ?? 'link';\n  const imageSourceKey = opts?.imageSourceKey ?? 'link';\n  const imageCaptionKey = opts?.imageCaptionKey ?? 'caption';\n\n  let children: Array<DeserializedNode<T>> = [{ text: '' }];\n\n  const nodeChildren = node.children;\n  if (nodeChildren && Array.isArray(nodeChildren) && nodeChildren.length > 0) {\n    children = nodeChildren.flatMap((c: MdastNode) =>\n      deserialize(\n        {\n          ...c,\n          ordered: node.ordered || false,\n        },\n        opts\n      )\n    );\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return {\n        type: types.heading[node.depth || 1],\n        children,\n      } as HeadingNode<T>;\n    case 'list':\n      return {\n        type: node.ordered ? types.ol_list : types.ul_list,\n        children,\n      } as ListNode<T>;\n    case 'listItem':\n      return { type: types.listItem, children } as ListItemNode<T>;\n    case 'paragraph':\n      return { type: types.paragraph, children } as ParagraphNode<T>;\n    case 'link':\n      return {\n        type: types.link,\n        [linkDestinationKey]: node.url,\n        children,\n      } as LinkNode<T>;\n    case 'image':\n      return {\n        type: types.image,\n        children: [{ text: '' }],\n        [imageSourceKey]: node.url,\n        [imageCaptionKey]: node.alt,\n      } as ImageNode<T>;\n    case 'blockquote':\n      return { type: types.block_quote, children } as BlockQuoteNode<T>;\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{ text: node.value }],\n      } as CodeBlockNode<T>;\n\n    case 'html':\n      if (node.value?.includes('<br>')) {\n        return {\n          break: true,\n          type: types.paragraph,\n          children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n        } as ParagraphNode<T>;\n      }\n      return { type: 'paragraph', children: [{ text: node.value || '' }] };\n\n    case 'emphasis':\n      return {\n        [types.emphasis_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      } as unknown as ItalicNode<T>;\n    case 'strong':\n      return {\n        [types.strong_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      } as unknown as BoldNode<T>;\n    case 'delete':\n      return {\n        [types.delete_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      } as unknown as StrikeThoughNode<T>;\n    case 'inlineCode':\n      return {\n        [types.inline_code_mark as string]: true,\n        text: node.value,\n        ...persistLeafFormats(children as Array<MdastNode>),\n      };\n    case 'thematicBreak':\n      return {\n        type: types.thematic_break,\n        children: [{ text: '' }],\n      } as ThematicBreakNode<T>;\n\n    case 'text':\n    default:\n      return { text: node.value || '' };\n  }\n}\n\nconst forceLeafNode = (children: Array<TextNode>) => ({\n  text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nfunction persistLeafFormats(\n  children: Array<MdastNode>\n): Omit<MdastNode, 'children' | 'type' | 'text'> {\n  return children.reduce((acc, node) => {\n    (Object.keys(node) as Array<keyof MdastNode>).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return;\n\n      acc[key] = node[key];\n    });\n\n    return acc;\n  }, {});\n}\n","import { BlockType, defaultNodeTypes, LeafType, NodeTypes } from './ast-types';\n\ninterface Options {\n  nodeTypes: NodeTypes;\n  listDepth?: number;\n  ignoreParagraphNewline?: boolean;\n}\n\nconst isLeafNode = (node: BlockType | LeafType): node is LeafType => {\n  return typeof (node as LeafType).text === 'string';\n};\n\nconst VOID_ELEMENTS: Array<keyof NodeTypes> = ['thematic_break', 'image'];\n\nconst BREAK_TAG = '\\n';\n\nexport default function serialize(\n  chunk: BlockType | LeafType,\n  opts: Options = { nodeTypes: defaultNodeTypes }\n) {\n  const {\n    nodeTypes: userNodeTypes = defaultNodeTypes,\n    ignoreParagraphNewline = false,\n    listDepth = 0,\n  } = opts;\n\n  let text = (chunk as LeafType).text || '';\n  let type = (chunk as BlockType).type || '';\n\n  const nodeTypes: NodeTypes = {\n    ...defaultNodeTypes,\n    ...userNodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...userNodeTypes.heading,\n    },\n  };\n\n  const LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n\n  let children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children\n      .map((c: BlockType | LeafType) => {\n        const isList = !isLeafNode(c)\n          ? (LIST_TYPES as string[]).includes(c.type || '')\n          : false;\n\n        const selfIsList = (LIST_TYPES as string[]).includes(chunk.type || '');\n\n        // Links can have the following shape\n        // In which case we don't want to surround\n        // with break tags\n        // {\n        //  type: 'paragraph',\n        //  children: [\n        //    { text: '' },\n        //    { type: 'link', children: [{ text: foo.com }]}\n        //    { text: '' }\n        //  ]\n        // }\n        let childrenHasLink = false;\n\n        if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n          childrenHasLink = chunk.children.some(\n            (f) => !isLeafNode(f) && f.type === nodeTypes.link\n          );\n        }\n\n        return serialize(\n          { ...c, parentType: type },\n          {\n            nodeTypes,\n            // WOAH.\n            // what we're doing here is pretty tricky, it relates to the block below where\n            // we check for ignoreParagraphNewline and set type to paragraph.\n            // We want to strip out empty paragraphs sometimes, but other times we don't.\n            // If we're the descendant of a list, we know we don't want a bunch\n            // of whitespace. If we're parallel to a link we also don't want\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              (ignoreParagraphNewline ||\n                isList ||\n                selfIsList ||\n                childrenHasLink) &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as BlockType).break,\n\n            // track depth of nested lists so we can add proper spacing\n            listDepth: (LIST_TYPES as string[]).includes(\n              (c as BlockType).type || ''\n            )\n              ? listDepth + 1\n              : listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    chunk.parentType === nodeTypes.paragraph &&\n    type !== nodeTypes.image\n  ) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '' && !VOID_ELEMENTS.find((k) => nodeTypes[k] === type))\n    return;\n\n  // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikethrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikethrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n\n      if (chunk.code) {\n        children = retainWhitespaceAndFormat(children, '`');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return `# ${children}`;\n    case nodeTypes.heading[2]:\n      return `## ${children}`;\n    case nodeTypes.heading[3]:\n      return `### ${children}`;\n    case nodeTypes.heading[4]:\n      return `#### ${children}`;\n    case nodeTypes.heading[5]:\n      return `##### ${children}`;\n    case nodeTypes.heading[6]:\n      return `###### ${children}`;\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return `> ${children}\\n`;\n\n    case nodeTypes.code_block:\n      return `\\`\\`\\`${\n        (chunk as BlockType).language || ''\n      }\\n${children}\\n\\`\\`\\`\\n`;\n\n    case nodeTypes.link:\n      return `[${children}](${(chunk as BlockType).url || ''})`;\n    case nodeTypes.image:\n      return `![${(chunk as BlockType).caption ?? ''}](${\n        (chunk as BlockType).url || ''\n      })`;\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return `\\n${children}\\n`;\n\n    case nodeTypes.listItem:\n      const isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n      const treatAsLeaf =\n        (chunk as BlockType).children.length === 1 &&\n        ((chunk as BlockType).children[0] as BlockType).type === 'lic' &&\n        isLeafNode(((chunk as BlockType).children[0] as BlockType).children[0]);\n\n      let spacer = '';\n      for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n      return `${spacer}${isOL ? '1.' : '-'} ${children}${\n        treatAsLeaf ? '\\n' : ''\n      }`;\n\n    case nodeTypes.paragraph:\n      return `${children}\\n`;\n\n    case nodeTypes.thematic_break:\n      return `\\n---\\n`;\n\n    default:\n      return children;\n  }\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nfunction retainWhitespaceAndFormat(string: string, format: string) {\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  let children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${format}${children}${reverseStr(format)}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = format + children + reverseStr(format);\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import { MdastNode, OptionType } from './ast-types';\nimport transform from './deserialize';\n\nexport default function plugin(opts?: OptionType) {\n  const compiler = (node: { children: Array<MdastNode> }) => {\n    return node.children.map((c) => transform(c, opts));\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n"],"names":["defaultNodeTypes","paragraph","block_quote","code_block","link","ul_list","ol_list","listItem","heading","emphasis_mark","strong_mark","delete_mark","inline_code_mark","thematic_break","image","deserialize","node","opts","types","nodeTypes","linkDestinationKey","imageSourceKey","imageCaptionKey","children","text","nodeChildren","Array","isArray","length","flatMap","c","ordered","type","depth","url","alt","language","lang","value","includes","replace","forceLeafNode","persistLeafFormats","map","k","join","reduce","acc","Object","keys","forEach","key","isLeafNode","VOID_ELEMENTS","BREAK_TAG","serialize","chunk","userNodeTypes","ignoreParagraphNewline","listDepth","LIST_TYPES","isList","selfIsList","childrenHasLink","some","f","parentType","find","strikethrough","bold","italic","retainWhitespaceAndFormat","code","caption","isOL","treatAsLeaf","spacer","string","format","frozenString","trim","fullFormat","reverseStr","formattedString","split","reverse","plugin","compiler","transform","Compiler"],"mappings":"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"}